<template>
    <!-- <a-row>
        <LayoutsInformationMiniGameBar/>
    </a-row> -->
    <div>
        <a-flex :justify="'space-between'" class="m-2 spin-text" :align="'center'">
            <h4><NuxtLink to="/information/mini-game/listMiniGame" exact class="link-sidebar"><ArrowLeftOutlined /> ‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</NuxtLink></h4>
            <div style="white-space: nowrap;">
                ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì {{ member.memberDetail.balance_event }} ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç
            </div>
        </a-flex>
        <br>
        <h2 class="m-2 center jackpot">üéâ ‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏Å‡∏á‡∏•‡πâ‡∏≠ üéâ</h2>
        <canvas ref="wheelRef" :width="canvasSize" :height="canvasSize" class="spin-wheel"></canvas>
        <div class="text-center">
            ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏Å‡∏°‡∏™‡πå {{coin}} ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç
        </div>
        <a-flex :justify="'center'">
            <!-- <a-table 
            :columns="dynamicColumns"
            :data-source="dataShow"
            bordered
            :scroll="{ x: 800, y: 700 }"
            :pagination="false"
            class="my-2"
            >
                <template #bodyCell="{ column, record,index }">
                    <template v-if="column.key === 'id'">
                        <div>{{ index + 1 }}</div>
                    </template>
                    <template v-else-if="column.key === 'Coin'">
                        <div>{{ record.Coin }}</div>
                    </template>
                    <template v-else-if="column.key === 'result_detail'">
                        <div>{{ record.result_detail }}</div>
                    </template>
                    <template v-else-if="column.key === 'status'">
                        <a-tag color="green" v-if="record.status == 2">‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à</a-tag>
                        <a-tag color="red" v-else-if="record.status == 3">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</a-tag>
                    </template>
                    <template v-else-if="column.key === 'created_at'">
                        <div>{{ dayjs(record.created_at).format('YYYY-MM-DD HH:mm:ss') }}</div>
                    </template>
                </template>
            </a-table> -->
            <a-col :span="24" :md="24" class="p-1">
                <h3>‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏Å‡∏á‡∏•‡πâ‡∏≠</h3>
                <div class="list-container my-2">
                    <a-row class="list">
                    <a-col :span="24" class="center">
                        ‡πÄ‡πÄ‡∏™‡∏î‡∏á 10 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
                    </a-col>
                    <a-col :span="24" class="my-1">
                        <a-flex :justify="'space-around'">
                        <a-col :span="4" class="center">‡πÄ‡∏Å‡∏°‡∏™‡πå</a-col>
                        <a-col :span="4" class="center">‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ</a-col>
                        <a-col :span="4" class="center">‡∏ú‡∏•‡∏ó‡∏µ‡πà‡∏≠‡∏≠‡∏Å</a-col>
                        <a-col :span="4" class="center">‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞</a-col>
                        <a-col :span="4" class="center">‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà</a-col>

                        </a-flex>
                    </a-col>
                    <a-col :span="24">
                        <hr />
                    </a-col>
                    <a-col :span="24" class="text-12">
                        <a-flex
                            :justify="'space-around'"
                            :align="'center'"
                            v-for="(data, index) in dataShow"
                            :key="data.id || index"
                            class="my-1"
                            >
                            <a-col :span="4" class="center">
                                <div>‡∏Å‡∏á‡∏•‡πâ‡∏≠</div>
                            </a-col>
                            <a-col :span="4" class="center">
                                <div>{{ data.Coin }}</div>
                            </a-col>
                            <a-col :span="4" class="center">
                                <div>{{ data.result_detail }}</div>
                            </a-col>
                            <a-col :span="4" class="center">
                                <a-tag color="green" v-if="data.status == 2">‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à</a-tag>
                                <a-tag color="red" v-else-if="data.status == 3">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</a-tag>
                            </a-col>
                            <a-col :span="4" class="center">
                                <div>{{ dayjs(data.created_at).format('YYYY-MM-DD HH:mm:ss') }}</div>
                            </a-col>
                        </a-flex>
                        <!-- <hr /> -->
                    </a-col>
                    </a-row>
                </div>
            </a-col>
        </a-flex>
    </div>
  </template>
  
  <script lang="ts" setup>
    import { ref, onMounted } from 'vue'
    import { ExclamationCircleOutlined } from '@ant-design/icons-vue';
    import { createVNode } from 'vue';
    import { Alert } from '~/components/alert/alertComponent';
    import { getSettingSpinWheelServices,spinWheelServices,getDataSpinWheelServices,getTransactionSpinWheelServices } from "~/services/miniGameServices";
    import dayjs from 'dayjs';
    
    import { memberStore } from '~/store/index';
    const member = memberStore();

    const dataShow = ref<any[]>([]);
    const allRecord = ref<number>(0);
    const coin = ref<number>(0);
  
    const spinGame = async () => {
        const data = await spinWheelServices();
        if (data.status === 'success') {
            targetIndex.value = data.data.i
            member.memberDetail.balance_event = data.data.coin
            spinWheel(data.data.i);
        }else{
            Alert("error",data.message)
        }
    };

    const getDataSpinGame = async () => {
        const data = await getDataSpinWheelServices();
        if (data.status === 'success') {
            // targetIndex.value = data.data.i
            member.memberDetail.balance_event = data.data.coin
            member.memberDetail.balance = data.data.amount
            // spinWheel(data.data.i);
        }else{
            Alert("error",data.message)
        }
    };

  const showConfirm = () => {
    Modal.confirm({
        title: '‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡∏Å‡∏á‡∏•‡πâ‡∏≠‡πÉ‡∏ä‡πà‡πÑ‡∏´‡∏°?',
        icon: createVNode(ExclamationCircleOutlined),
        content: createVNode('div', { style: 'color:red;' }, `‡πÉ‡∏ä‡πâ `+coin.value+` ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô`),
        onOk() {
        console.log('OK');
        // spinWheel();
            if(spinning){
                Alert("error","‡πÄ‡∏Å‡∏°‡∏™‡πå‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡∏ú‡∏•")
            }else{
                if(member.memberDetail.balance_event < coin.value){
                    Alert("error","‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô ‡∏Ñ‡∏∑‡∏≠ "+coin.value)
                }else{
                    spinGame();
                    // spinWheel();
                    // getDataSpinGame();
                }
            }
        },
        onCancel() {
        console.log('Cancel');
        },
        class: 'test',
    });
    };


const showWinner = (winer:string) => {
    getDataSpinGame();
    Modal.confirm({
        title: 'Do you Want to delete these items?',
        icon: createVNode(ExclamationCircleOutlined),
        content: createVNode('div', { style: 'color:red;' }, winer),
        onOk() {
        console.log('OK');
        drawWheel()
        getTransactionSpinWheel();
        },
        onCancel() {
        console.log('Cancel');
        },
        class: 'test',
    });
};

  const canvasSize = ref(500); // ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏≠‡∏á Canvas
  const circleRadius = ref(40);
  const aspectRatio = 1
  const wheelRef = ref<HTMLCanvasElement | null>(null) // ‡∏£‡∏∞‡∏ö‡∏∏‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á wheelRef ‡πÉ‡∏´‡πâ‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô
  const segments = ref<string[]>([]);
  const colors = ref<string[]>([]);
  var targetIndex = ref(0);
  
  let rotationAngle = 0
  let sum = 0
  let spinning = false
  
  const radius = canvasSize.value / 2.3  // ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏≠‡∏á‡∏ß‡∏á‡∏•‡πâ‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏•‡πá‡∏Å‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô 1/3 ‡∏Ç‡∏≠‡∏á canvas
//   const circleRadius = 40 // ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏≠‡∏á‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á
  
const getSettingGame = async () => {
  const data = await getSettingSpinWheelServices();
  if (data.status === 'success') {
    const configValue = data.data.data.config_value;
    coin.value = data.data.data.game_coin;
    segments.value = configValue.map((item: any) => item.rewards); // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ segments
    colors.value = configValue.map((item: any) => item.bgColor);   // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏™‡∏µ
//     const segments = ['Prize 1', 'Prize 2', 'Prize 3', 'Prize 4', 'Prize 5', 'Prize 6', 'Prize 7', 'Prize 8', 'Prize 9', 'Prize 10']
//   const colors = ['#FF5733', '#33FF57', '#5733FF', '#F1C40F', '#8E44AD', '#33FF57', '#5733FF', '#FF5733', '#F1C40F', '#8E44AD']
    
    drawWheel(); // ‡∏ß‡∏≤‡∏î‡∏ß‡∏á‡∏•‡πâ‡∏≠‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
  }
};

const getTransactionSpinWheel = async () => {
  const data = await getTransactionSpinWheelServices();
  if (data.status === 'success') {
    dataShow.value = data.data.transactions
    allRecord.value = data.data.total_count
  }
};

  // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ß‡∏≤‡∏î‡∏ß‡∏á‡∏•‡πâ‡∏≠
  const drawWheel = () => {
    const canvas = wheelRef.value
    if (!canvas) return
  
    const ctx = canvas.getContext('2d')
    if (!ctx) return // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ ctx ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô null
  
    const centerX = canvas.width / 2
    const centerY = canvas.height / 2
    const segmentAngle = (2 * Math.PI) / segments.value.length;
  
    ctx.clearRect(0, 0, canvas.width, canvas.height)
  
    // ‡∏ß‡∏≤‡∏î‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á
    ctx.beginPath()
    ctx.arc(centerX, centerY, circleRadius.value, 0, 2 * Math.PI)
    ctx.fillStyle = '#FFFFFF' // ‡∏™‡∏µ‡∏Ç‡∏≠‡∏á‡∏ß‡∏á‡∏Å‡∏•‡∏°
    ctx.fill()
    ctx.strokeStyle = '#000000'
    ctx.lineWidth = 2
    ctx.stroke()
    ctx.closePath()
  
    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏á‡∏≤‡∏£‡∏≠‡∏ö‡∏ß‡∏á‡∏Å‡∏•‡∏°
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'  // ‡∏™‡∏µ‡πÄ‡∏á‡∏≤
    ctx.shadowBlur = 15  // ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏ö‡∏•‡∏≠‡∏Ç‡∏≠‡∏á‡πÄ‡∏á‡∏≤
    ctx.shadowOffsetX = 5  // ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏á‡∏≤‡πÉ‡∏ô‡πÅ‡∏ô‡∏ß‡πÅ‡∏Å‡∏ô X
    ctx.shadowOffsetY = 5  // ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏á‡∏≤‡πÉ‡∏ô‡πÅ‡∏ô‡∏ß‡πÅ‡∏Å‡∏ô Y
  
    for (let i = 0; i < segments.value.length; i++) {
        const startAngle = i * segmentAngle - Math.PI / 2 + rotationAngle
        const endAngle = startAngle + segmentAngle
    
        ctx.beginPath()
        ctx.moveTo(centerX, centerY)
        ctx.arc(centerX, centerY, radius, startAngle, endAngle)
        ctx.fillStyle = colors.value[i % colors.value.length];
        ctx.fill()
        ctx.strokeStyle = '#FFFFFF'
        ctx.lineWidth = 2
        ctx.stroke()
        ctx.closePath()
    
        // ‡∏ß‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
        ctx.save()
        ctx.translate(centerX, centerY)
        ctx.rotate(startAngle + segmentAngle / 2)
        ctx.textAlign = 'right'
        ctx.fillStyle = '#FFFFFF'
        ctx.font = 'bold 16px Arial'
        ctx.fillText(segments.value[i], radius - 10, 10)
        ctx.restore()
    }
    
    drawPointer(centerX, centerY);
    // ‡∏ß‡∏≤‡∏î‡∏•‡∏π‡∏Å‡∏®‡∏£‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏ß‡∏á‡∏•‡πâ‡∏≠
    circlePointer(centerX, centerY)
  }
  
  // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ß‡∏≤‡∏î‡∏•‡∏π‡∏Å‡∏®‡∏£‡∏ä‡∏µ‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á
  const drawPointer = (centerX: number, centerY: number) => {
    const canvas = wheelRef.value;
    if (!canvas) return;
  
    const ctx = canvas.getContext('2d');
    if (!ctx) return; // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ ctx ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô null
    const pointerWidth = 50; // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏•‡∏π‡∏Å‡∏®‡∏£
    const pointerHeight = 40; // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ç‡∏≠‡∏á‡∏•‡∏π‡∏Å‡∏®‡∏£
    const pointerColor = '#FF0000'; // ‡∏™‡∏µ‡∏Ç‡∏≠‡∏á‡∏•‡∏π‡∏Å‡∏®‡∏£
  
    // ‡∏ß‡∏≤‡∏î‡∏•‡∏π‡∏Å‡∏®‡∏£‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡∏ß‡∏á‡∏•‡πâ‡∏≠
    ctx.beginPath();
    ctx.moveTo(centerX, radius - pointerHeight); // ‡∏õ‡∏•‡∏≤‡∏¢‡∏ö‡∏ô‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏•‡∏π‡∏Å‡∏®‡∏£
    ctx.lineTo(centerX - pointerWidth / 2, radius); // ‡∏°‡∏∏‡∏°‡∏ã‡πâ‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á‡∏ê‡∏≤‡∏ô‡∏•‡∏π‡∏Å‡∏®‡∏£
    ctx.lineTo(centerX + pointerWidth / 2, radius); // ‡∏°‡∏∏‡∏°‡∏Ç‡∏ß‡∏≤‡∏Ç‡∏≠‡∏á‡∏ê‡∏≤‡∏ô‡∏•‡∏π‡∏Å‡∏®‡∏£
    ctx.closePath();
    ctx.fillStyle = pointerColor;
    ctx.fill();
  };
  
  // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ß‡∏≤‡∏î‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏ß‡∏á‡∏•‡πâ‡∏≠
  const circlePointer = (centerX: number, centerY: number) => {
    const canvas = wheelRef.value
    if (!canvas) return
  
    const ctx = canvas.getContext('2d')
    if (!ctx) return; // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ ctx ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô null
    const color = '#FF0000'  // ‡∏™‡∏µ‡∏Ç‡∏≠‡∏á‡∏ß‡∏á‡∏Å‡∏•‡∏°‡πÅ‡∏•‡∏∞‡∏•‡∏π‡∏Å‡∏®‡∏£
  
    // ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏≤‡πÉ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ß‡∏≤‡∏î‡∏•‡∏π‡∏Å‡∏®‡∏£
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'  // ‡∏•‡∏ö‡πÄ‡∏á‡∏≤
    ctx.shadowBlur = 15
    ctx.shadowOffsetX = 0
    ctx.shadowOffsetY = 0
  
    // ‡∏ß‡∏≤‡∏î‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏ß‡∏á‡∏•‡πâ‡∏≠
    ctx.beginPath()
    ctx.arc(centerX, centerY, circleRadius.value, 0, 2 * Math.PI)
    ctx.fillStyle = color  // ‡∏™‡∏µ‡∏Ç‡∏≠‡∏á‡∏ß‡∏á‡∏Å‡∏•‡∏°
    ctx.fill()
  
    // ‡∏ß‡∏≤‡∏î‡∏Å‡∏£‡∏≠‡∏ö‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß
    ctx.lineWidth = 4  // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏ô‡∏≤‡∏Ç‡∏≠‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏Å‡∏£‡∏≠‡∏ö
    ctx.strokeStyle = '#FFFFFF'  // ‡∏™‡∏µ‡∏Ç‡∏≠‡∏á‡∏Å‡∏£‡∏≠‡∏ö
    ctx.stroke()  // ‡∏ß‡∏≤‡∏î‡∏Å‡∏£‡∏≠‡∏ö‡∏ß‡∏á‡∏Å‡∏•‡∏°
  
    // ‡∏ß‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏ô‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á
    ctx.save()
    ctx.font = 'bold 16px Arial' // ‡∏ï‡∏±‡πâ‡∏á‡∏ü‡∏≠‡∏ô‡∏ï‡πå
    ctx.fillStyle = '#FFFFFF' // ‡∏™‡∏µ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
    ctx.textAlign = 'center' // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏•‡∏≤‡∏á
    ctx.textBaseline = 'middle' // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏•‡∏≤‡∏á
    ctx.fillText('Spin', centerX, centerY) // ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ß‡∏≤‡∏î‡πÉ‡∏ô‡∏ß‡∏á‡∏Å‡∏•‡∏°
    ctx.restore()
  }
  

  // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà canvas
    const handleCanvasClick = (event: MouseEvent) => {
        const canvas = wheelRef.value;
        if (!canvas) return;

        const rect = canvas.getBoundingClientRect(); // ‡∏Ç‡∏≠‡∏ö‡∏Ç‡∏≠‡∏á canvas ‡πÉ‡∏ô‡∏à‡∏≠
        const scaleX = canvas.width / rect.width; // ‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏Ç‡∏¢‡∏≤‡∏¢‡πÉ‡∏ô‡πÅ‡∏Å‡∏ô X
        const scaleY = canvas.height / rect.height; // ‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏Ç‡∏¢‡∏≤‡∏¢‡πÉ‡∏ô‡πÅ‡∏Å‡∏ô Y

        const clickX = (event.clientX - rect.left) * scaleX; // ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á X ‡∏ó‡∏µ‡πà‡∏Ñ‡∏•‡∏¥‡∏Å
        const clickY = (event.clientY - rect.top) * scaleY; // ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á Y ‡∏ó‡∏µ‡πà‡∏Ñ‡∏•‡∏¥‡∏Å

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡∏®‡∏π‡∏ô‡∏¢‡πå‡∏Å‡∏•‡∏≤‡∏á
        const distanceFromCenter = Math.sqrt(
            Math.pow(clickX - centerX, 2) + Math.pow(clickY - centerY, 2)
        );

        if (distanceFromCenter <= circleRadius.value) {
            showConfirm(); // ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡πÉ‡∏ô‡∏ß‡∏á‡∏Å‡∏•‡∏°
        }
    };

    const handleMouseMove = (event: MouseEvent) => {
        const canvas = wheelRef.value;
        if (!canvas) return;

        const rect = canvas.getBoundingClientRect(); // ‡∏Ç‡∏≠‡∏ö‡∏Ç‡∏≠‡∏á canvas ‡πÉ‡∏ô‡∏à‡∏≠
        const scaleX = canvas.width / rect.width; // ‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏Ç‡∏¢‡∏≤‡∏¢‡πÉ‡∏ô‡πÅ‡∏Å‡∏ô X
        const scaleY = canvas.height / rect.height; // ‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏Ç‡∏¢‡∏≤‡∏¢‡πÉ‡∏ô‡πÅ‡∏Å‡∏ô Y

        const clickX = (event.clientX - rect.left) * scaleX; // ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á X ‡∏ó‡∏µ‡πà‡∏Ñ‡∏•‡∏¥‡∏Å
        const clickY = (event.clientY - rect.top) * scaleY; // ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á Y ‡∏ó‡∏µ‡πà‡∏Ñ‡∏•‡∏¥‡∏Å

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡∏®‡∏π‡∏ô‡∏¢‡πå‡∏Å‡∏•‡∏≤‡∏á
        const distanceFromCenter = Math.sqrt(
            Math.pow(clickX - centerX, 2) + Math.pow(clickY - centerY, 2)
        );

        if (distanceFromCenter <= circleRadius.value) {
            canvas.style.cursor = 'pointer'; // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô pointer ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ß‡∏á‡∏Å‡∏•‡∏°
        } else {
            canvas.style.cursor = 'default'; // ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ cursor ‡πÄ‡∏õ‡πá‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏≠‡∏Å‡∏ô‡∏≠‡∏Å‡∏ß‡∏á‡∏Å‡∏•‡∏°
        }
    };

  // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏°‡∏∏‡∏ô‡∏ß‡∏á‡∏•‡πâ‡∏≠
const spinWheel = (targetIndex:number) => {
    if (spinning) return;
    spinning = true;
    // 5 data ‡πÄ‡πÄ‡∏ô‡∏∞‡∏ô‡∏≥ 11 row

    const spinDuration = 10000; // ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏°‡∏¥‡∏•‡∏•‡∏¥‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
    // const targetIndex = 1; // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡πÅ‡∏ö‡∏ö‡∏™‡∏∏‡πà‡∏°
    const segmentAngle = (2 * Math.PI) / segments.value.length;
    // const targetAngle = 0;
    // const round = (targetIndex+segmentAngle)+((segmentAngle*segments.length)*5);
    const roll = 20;
    // var roll_check = 0;
    const randomNumber = (Math.random()*segmentAngle);
    console.log("randomNumber = "+randomNumber);
    const round = ((segmentAngle*segments.value.length)*roll)-randomNumber-(targetIndex*segmentAngle);


    const segmentsCount = segments.value.length;


    // const totalRotation = (segmentAngle * segmentsCount * roll) - targetAngle - randomNumber;
    // const speed = round/2;
    // var checkDivide = 1;
    // var check = 0;

    const startTime = performance.now();
    const easeOutCubic = (t: number) => 1 - Math.pow(1 - t, 3);
    const easeOutQuint = (t: number) => 1 - Math.pow(1 - t, 5); 

    const spin = (time: DOMHighResTimeStamp) => {

        const elapsedTime = time - startTime; // ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏õ
        const progress = elapsedTime / spinDuration; // ‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏ß‡∏•‡∏≤
        const easedProgress = easeOutCubic(progress);
        // const easedProgress = easeOutQuint(progress);

        if (progress >= 1) {
            // ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏£‡∏ö‡πÄ‡∏ß‡∏•‡∏≤
            spinning = false;
            drawWheel();
            determineWinner(targetIndex); // ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞
            return;
        }

        console.log(easedProgress);
        rotationAngle = easedProgress * round;
        rotationAngle %= 2 * Math.PI;
        
        
        // if(rotationAngle >= round){
        //     rotationAngle = targetAngle;
        //     spinning = false;
        //     determineWinner(targetIndex);
        //     return;
        // }

        // // const progress = elapsedTime / spinDuration;
        // // const easeOut = Math.pow(1 - progress, 3); // ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÉ‡∏Å‡∏•‡πâ‡∏´‡∏¢‡∏∏‡∏î
        // console.log("test " +roll_check +"<"+ speed);
        // if(roll_check < speed){
        //     // rotationAngle += segmentAngle/checkDivide;
        //     rotationAngle += 0.01
        // }else{
        //     rotationAngle += segmentAngle/checkDivide;
        // }
        // // rotationAngle = rotationAngle + 0.01
        // console.log("segmentAngle = "+(segmentAngle/100));
        // // rotationAngle += 0.
        // console.log("rotationAngle = "+rotationAngle);
        // console.log("round = "+round);
        // check = check+1
        // console.log(`${check} = ${segments.value.length}`);
        
        // if(check == segments.value.length){
        //     checkDivide = checkDivide+0.3
        //     check = 0
        //     roll_check = roll_check+1
        //     console.log("roll_check = "+roll_check);
            
        // }
        // console.log("checkDivide = "+checkDivide);
        
        // sum = sum + rotationAngle
        
        // console.log(`rotationAngle = ${rotationAngle} `);
        // sum = sum + rotationAngle
        // console.log(`sum = ${sum} `);
        // rotationAngle %= 2 * Math.PI;

        // console.log(`${elapsedTime} / ${spinDuration} = ${progress}`);
        // console.log(`easeOut = ${easeOut} `);
        // console.log(`rotationAngles = ${rotationAngle} `);
        // rotationAngle += 4

        drawWheel();

        requestAnimationFrame(spin);
    };

    requestAnimationFrame(spin);
    };
  // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•
  const determineWinner = (number:number) => {
    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏î‡∏±‡∏ä‡∏ô‡∏µ‡∏Ç‡∏≠‡∏á‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ (‡πÄ‡∏ä‡πà‡∏ô ‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà‡∏™‡∏≠‡∏á)
    // const targetIndex = number; // ‡∏î‡∏±‡∏ä‡∏ô‡∏µ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà 0

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏°‡∏∏‡∏°‡∏ó‡∏µ‡πà‡∏•‡∏π‡∏Å‡∏®‡∏£‡∏ï‡πâ‡∏≠‡∏á‡∏ä‡∏µ‡πâ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
    // const segmentAngle = (2 * Math.PI) / segments.length;
    // console.log("targetIndex = "+targetIndex);
    // console.log("segmentAngle = "+segmentAngle);
    
    // const targetAngle = segmentAngle * targetIndex;
    // console.log("targetAngle = "+targetAngle);

    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ rotationAngle ‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏°‡∏∏‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÑ‡∏î‡πâ
    // rotationAngle = number-1;

    // ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ
    showWinner(`‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•: ${segments.value[number]}`);
    };
  
const resizeCanvas = () => {
    const width = window.innerWidth * 0.8; // 80% ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
    console.log(width);
    
    const size = Math.min(width, 500); // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 500px
    canvasSize.value = size;
    circleRadius.value = size / 12; // ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏≠‡∏á‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏Å‡∏•‡∏≤‡∏á‡∏à‡∏∞‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° canvas
    const canvas = wheelRef.value;
    
    if (canvas) {
        canvas.width = size;
        canvas.height = size * aspectRatio;
        console.log("ssssss");
        
        drawWheel(); // ‡∏ß‡∏≤‡∏î‡πÉ‡∏´‡∏°‡πà‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î
    }
};

  onMounted(() => {
    // resizeCanvas();
    getSettingGame();
    getTransactionSpinWheel();
    drawWheel();
    const canvas = wheelRef.value;
    if (canvas) {
        console.log("aaaaaaaa");
        
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousemove', handleMouseMove);
    }
  })
  
  definePageMeta({
    layout: 'information'
  })
  </script>
  
  <style scoped>
    .spin-wheel {
        display: block;
        margin: 0 auto;
        border-radius: 50%;
        width: 100%;
        max-width: 500px;
        min-width: 300px;  /* ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ */
        min-height: 300px; /* ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ */
        height: auto;
    }
    .spin-button {
        display: block;
        margin: 20px auto;
        padding: 10px 20px;
        background-color: #1abc9c;
        color: #fff;
        font-size: 18px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    .spin-button:hover {
        background-color: #16a085;
    }
    .spin-text {
        font-size: clamp(10px, 2vw, 14px);  /* ‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î 12px, ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 24px ‡πÅ‡∏•‡∏∞‡∏ï‡∏≤‡∏° viewport */
    }
    .text-center{
        text-align: center;
    }
    table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: center;
    }
    .list{
        background: linear-gradient(#2c002c, #100f4e) !important;
        border-radius: 10px;
        padding: 1rem 1rem;
    }

    .text-12 div{
        font-size: 12px !important;
    }

    .jackpot {
        font-size: 1.5rem;
        font-weight: bold;
        text-transform: uppercase;
        color: #ffd700; /* ‡∏™‡∏µ‡∏ó‡∏≠‡∏á */
        text-shadow: 0 0 10px #ffd700, 0 0 20px #ffa500, 0 0 30px #ff4500;
        transition: transform 0.3s ease;
        cursor: pointer;
    }
    @media screen and (max-width: 1100px) {
        .list-container {
            max-width: 100%;
            overflow-x: auto;
        }
        .list{
            width: 600px;
        }
    }
    @media screen and (max-width: 767px) {
        .list{
            width: 100%;
        }
    }

    @media screen and (max-width: 600px) {
        .list{
            width: 600px;
        }
    }
    /* th {
        background-color: #f4b400;
        color: white;
    }
    tr:nth-child(even) {
        background-color: #f9f9f9;
    }
    tr:hover {
        background-color: #f1f1f1;
    }
    .status-online {
        color: green;
        font-weight: bold;
    }
    .status-maintenance {
        color: red;
        font-weight: bold;
    } */
  </style>
  